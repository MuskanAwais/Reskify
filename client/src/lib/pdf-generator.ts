import jsPDF from 'jspdf';
import 'jspdf-autotable';

// Extend jsPDF types for autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface User {
  id: number;
  username: string;
  email: string;
  companyName: string;
  primaryTrade: string;
}

interface SwmsDocument {
  id: string | number;
  title: string;
  tradeType: string;
  projectLocation: string;
  activities: string[];
  riskAssessments?: Array<{
    hazard: string;
    riskLevel: string;
    controlMeasures: string | string[];
    responsiblePerson: string;
  }>;
  safetyMeasures?: Array<{
    category: string;
    measures: string[];
    equipment: string[];
    procedures: string[];
  }>;
  complianceCodes: string[];
  status: string;
  aiEnhanced: boolean;
  createdAt: string | Date;
  documentHash?: string;
}

export async function generateProtectedPDF(document: SwmsDocument, user: User | null): Promise<Blob> {
  try {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    let yPosition = 20;

    // Add full-page watermark pattern
    const addFullPageWatermark = () => {
      pdf.setFontSize(12);
      pdf.setTextColor(240, 240, 240); // Very light gray
      pdf.setFont('helvetica', 'bold');
      
      const watermarkText = `${document.title || 'SWMS'} - ${document.id || 'N/A'} - ${document.projectLocation || 'Location'}`;
      
      // Create diagonal watermark pattern across the page
      for (let x = -100; x < pageWidth + 100; x += 120) {
        for (let y = 0; y < pageHeight + 100; y += 80) {
          pdf.text(watermarkText, x, y, { 
            angle: 45,
            align: 'left'
          });
        }
      }
    };
    
    // Apply watermark to current page
    addFullPageWatermark();
    
    // Reset text color for main content
    pdf.setTextColor(0, 0, 0);

    // Header Section
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.text('SAFE WORK METHOD STATEMENT', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 15;

    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'normal');
    pdf.text(document.title, pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 20;

    // Protection Notice Box
    pdf.setDrawColor(220, 53, 69); // Red border
    pdf.setFillColor(254, 242, 242); // Light red background
    pdf.rect(20, yPosition, pageWidth - 40, 20, 'FD');
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(220, 53, 69);
    pdf.text('ðŸ›¡ï¸ PROTECTED DOCUMENT', 25, yPosition + 8);
    pdf.setFont('helvetica', 'normal');
    pdf.text('This SWMS is digitally protected and cannot be copied or modified without authorization.', 25, yPosition + 15);
    
    yPosition += 35;
    pdf.setTextColor(0, 0, 0);

    // Document Information Table
    const documentInfo = [
      ['Project Details', ''],
      ['Trade Type', document.tradeType],
      ['Location', document.projectLocation],
      ['Status', document.status.replace('_', ' ').toUpperCase()],
      ['Date Created', new Date(document.createdAt).toLocaleDateString()],
      ['Document ID', `SWM-${document.id}`],
      ['AI Enhanced', document.aiEnhanced ? 'Yes' : 'No']
    ];

    if (user) {
      documentInfo.push(
        ['', ''],
        ['Company Information', ''],
        ['Generated By', user.username],
        ['Company', user.companyName],
        ['Primary Trade', user.primaryTrade]
      );
    }

    pdf.autoTable({
      startY: yPosition,
      head: [['Field', 'Value']],
      body: documentInfo,
      theme: 'grid',
      headStyles: { fillColor: [21, 101, 192] }, // Primary blue
      alternateRowStyles: { fillColor: [248, 249, 250] },
      margin: { left: 20, right: 20 },
      columnStyles: {
        0: { fontStyle: 'bold', cellWidth: 50 },
        1: { cellWidth: 'auto' }
      }
    });

    yPosition = (pdf as any).lastAutoTable.finalY + 20;

    // Activities Section
    if (document.activities && document.activities.length > 0) {
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Work Activities', 20, yPosition);
      yPosition += 10;

      const activitiesData = document.activities.map((activity, index) => [
        (index + 1).toString(),
        activity
      ]);

      pdf.autoTable({
        startY: yPosition,
        head: [['#', 'Activity']],
        body: activitiesData,
        theme: 'striped',
        headStyles: { fillColor: [21, 101, 192] },
        margin: { left: 20, right: 20 },
        columnStyles: {
          0: { cellWidth: 20 },
          1: { cellWidth: 'auto' }
        }
      });

      yPosition = (pdf as any).lastAutoTable.finalY + 20;
    }

    // Risk Assessment Section
    if (document.riskAssessments && document.riskAssessments.length > 0) {
      // Check if we need a new page
      if (yPosition > pageHeight - 60) {
        pdf.addPage();
        yPosition = 20;
      }

      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Risk Assessment Matrix', 20, yPosition);
      yPosition += 10;

      const riskData = document.riskAssessments.map(risk => [
        risk.hazard,
        risk.riskLevel.toUpperCase(),
        Array.isArray(risk.controlMeasures) 
          ? risk.controlMeasures.join('\n') 
          : risk.controlMeasures,
        risk.responsiblePerson
      ]);

      const getRiskColor = (riskLevel: string) => {
        switch (riskLevel.toLowerCase()) {
          case 'low': return [34, 197, 94]; // Green
          case 'medium': return [234, 179, 8]; // Yellow
          case 'high': return [249, 115, 22]; // Orange
          case 'extreme': return [239, 68, 68]; // Red
          default: return [107, 114, 128]; // Gray
        }
      };

      pdf.autoTable({
        startY: yPosition,
        head: [['Hazard', 'Risk Level', 'Control Measures', 'Responsible Person']],
        body: riskData,
        theme: 'grid',
        headStyles: { fillColor: [21, 101, 192] },
        margin: { left: 20, right: 20 },
        columnStyles: {
          0: { cellWidth: 40 },
          1: { cellWidth: 25 },
          2: { cellWidth: 60 },
          3: { cellWidth: 35 }
        },
        didParseCell: function(data) {
          if (data.column.index === 1 && data.section === 'body') {
            const riskLevel = data.cell.text[0];
            const color = getRiskColor(riskLevel);
            data.cell.styles.fillColor = color;
            data.cell.styles.textColor = [255, 255, 255];
            data.cell.styles.fontStyle = 'bold';
          }
        }
      });

      yPosition = (pdf as any).lastAutoTable.finalY + 20;
    }

    // Safety Measures Section
    if (document.safetyMeasures && document.safetyMeasures.length > 0) {
      // Check if we need a new page
      if (yPosition > pageHeight - 60) {
        pdf.addPage();
        yPosition = 20;
      }

      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Safety Measures', 20, yPosition);
      yPosition += 10;

      document.safetyMeasures.forEach(measure => {
        const measureData = [
          ['Category', measure.category],
          ['Measures', measure.measures.join('\n')],
          ['Equipment', measure.equipment.join('\n')],
          ['Procedures', measure.procedures.join('\n')]
        ];

        pdf.autoTable({
          startY: yPosition,
          body: measureData,
          theme: 'striped',
          margin: { left: 20, right: 20 },
          columnStyles: {
            0: { fontStyle: 'bold', cellWidth: 30 },
            1: { cellWidth: 'auto' }
          }
        });

        yPosition = (pdf as any).lastAutoTable.finalY + 10;
      });
    }

    // Compliance Codes Section
    if (document.complianceCodes && document.complianceCodes.length > 0) {
      // Check if we need a new page
      if (yPosition > pageHeight - 40) {
        pdf.addPage();
        yPosition = 20;
      }

      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Applicable Safety Codes & Standards', 20, yPosition);
      yPosition += 10;

      const codesData = document.complianceCodes.map((code, index) => [
        (index + 1).toString(),
        code
      ]);

      pdf.autoTable({
        startY: yPosition,
        head: [['#', 'Code/Standard']],
        body: codesData,
        theme: 'striped',
        headStyles: { fillColor: [21, 101, 192] },
        margin: { left: 20, right: 20 },
        columnStyles: {
          0: { cellWidth: 20 },
          1: { cellWidth: 'auto' }
        }
      });

      yPosition = (pdf as any).lastAutoTable.finalY + 20;
    }

    // Footer with protection notice
    const totalPages = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Page number
      pdf.setFontSize(10);
      pdf.setTextColor(107, 114, 128);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - 30, pageHeight - 10);
      
      // Document hash/protection info
      if (document.documentHash) {
        pdf.setFontSize(8);
        pdf.text(`Document Hash: ${document.documentHash}`, 20, pageHeight - 5);
      }
      
      // Generation timestamp
      pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, pageHeight - 10);
    }

    // Add document protection metadata
    pdf.setProperties({
      title: `SWMS - ${document.title}`,
      subject: 'Safe Work Method Statement',
      author: user ? `${user.username} (${user.companyName})` : 'SWMS Builder Pro',
      keywords: `SWMS, Safety, ${document.tradeType}, Australian Construction`,
      creator: 'SWMS Builder Pro - Australian Construction Safety',
      producer: 'SWMS Builder Pro'
    });

    // Generate blob with protection settings
    const pdfBlob = pdf.output('blob');
    
    // Add additional protection layer (in a real implementation, this would include encryption)
    return new Blob([pdfBlob], { 
      type: 'application/pdf',
    });

  } catch (error) {
    console.error('PDF generation error:', error);
    throw new Error(`Failed to generate PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export function createDocumentHash(document: SwmsDocument): string {
  // Generate a simple hash for document protection
  const dataString = JSON.stringify({
    id: document.id,
    title: document.title,
    tradeType: document.tradeType,
    activities: document.activities,
    timestamp: new Date().toISOString()
  });
  
  // Simple hash function (in production, use a proper cryptographic hash)
  let hash = 0;
  for (let i = 0; i < dataString.length; i++) {
    const char = dataString.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  
  return Math.abs(hash).toString(16).toUpperCase();
}

export function validateDocumentIntegrity(document: SwmsDocument, providedHash: string): boolean {
  const calculatedHash = createDocumentHash(document);
  return calculatedHash === providedHash;
}

// Additional PDF security features
export function addWatermark(pdf: jsPDF, text: string = 'PROTECTED DOCUMENT'): void {
  const pageCount = pdf.internal.getNumberOfPages();
  
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    
    // Save current graphics state
    pdf.saveGraphicsState();
    
    // Set watermark properties
    pdf.setGState(new pdf.GState({ opacity: 0.1 }));
    pdf.setTextColor(150, 150, 150);
    pdf.setFontSize(50);
    pdf.setFont('helvetica', 'bold');
    
    // Add diagonal watermark
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    
    pdf.text(text, pageWidth / 2, pageHeight / 2, {
      angle: 45,
      align: 'center'
    });
    
    // Restore graphics state
    pdf.restoreGraphicsState();
  }
}
